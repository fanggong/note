---
title: "stringr"
author: "Fang Yongchao"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
    number_section: true
  runtime: shiny
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(warning = FALSE)
library(stringr)
library(microbenchmark)
library(shiny)
options(digits = 4)
```

# 概要

`stringr`包对字符串进行操作，主要包含四种类型的函数：

- 对单个字符串中的字符的操作
- 对空格的增加、删除或其他操作
- locale sensitive：可以理解为针对不同语言输出会不一样的函数
- pattern 匹配函数：支持四种不同的匹配模式，最常用的还是正则表达式

# 对单个字符串进行操作

此类函数对单个字符串进行操作，由于每个函数都已被向量化，故可以直接以字符串向量为参数

## `str_length()`
返回字符串长度
```{r}
str_length(c("fang", "方", NA_character_))
```
base R中使用`nchar()`函数
```{r}
nchar(c("fang", "方", NA_character_))
```
两个函数在性能上没有太大差别
```{r}
stringr <- 'str_length(c("fang", "方", NA_character_))'
base_r <- 'nchar(c("fang", "方", NA_character_))'
microbenchmark(
  eval(parse(text = stringr)), eval(parse(text = base_r))
)
```
但是`nchar()`提供了一些别的参数，比如**type**，可以选择计算字符串长度的方式（bytes、characters或者是width），以及如果处理缺失值的参数方**allowNA**和**keepNA**。

## `str_sub()`
返回和替换字符串子串
```{r}
string <- c("fang yongchao", "stringr")
str_sub(string, start = 1, end = 4)
str_sub(string, start = 1, end = 4) <- "????"
string
```
base R中使用`substr()`或`substring()`函数
```{r}
string <- c("fang yongchao", "stringr")
substr(string, start = 1, stop = 4)
substring(string, first = 1, last = 4)
substring(string, first = 1, last = 4) <- "????"
string
```
性能上也无明显差别
```{r}
string <- c("fang", "yong", "chap")
stringr <- 'str_sub(string, start = 1, end = 4)'
base_r1 <- 'substr(string, start = 1, stop = 4)'
base_r2 <- 'substring(string, first = 1, last = 4)'
microbenchmark(
  eval(parse(text = stringr)), 
  eval(parse(text = base_r1)), 
  eval(parse(text = base_r2))
)
```
## `str_dup()`和`str_c()`
复制和连接字符串
```{r}
str_dup(c("fang", "yong", "chao"), 3)
str_c("fang", " ", "yong", "chao")
```
base R中在我的知识范围内没有找到某个函数来实现该功能，只能通过`paste()`和`rep()`一起使用来达到同样的效果
```{r}
sapply(c("fang", "yong", "chao"), function(s) paste(rep(s, 3), collapse = ""))
paste("fang", " ", "yong", "chao", sep = "")
```
`str_c()`和`paste()`之间的性能几乎没有差距
```{r}
stringr <- 'str_c("fang", "yong", "chao")'
base_r <- 'paste("fang", "yong", "chao", "")'
microbenchmark(
  eval(parse(text = stringr)),
  eval(parse(text = base_r))
)
```
但是作为用base R来实现`str_dup()`性能就有点惨不忍睹了，应该base R里有相关的实现函数只是我不知道吧...
```{r}
string <- c("fang", "yong", "chao")
my_dup <- function(s) paste(rep(s, 3), collapse = "")
stringr <- 'str_dup(string, 3)'
base_r <- 'sapply(string, my_dup)'
microbenchmark(
  eval(parse(text = stringr)),
  eval(parse(text = base_r))
)
```

# 对空格进行操作

此类函数包含增加、删除、修改空格三个函数

## `str_pad()`
通过添加字符改变字符串长度
```{r}
# 添加空格的方向可为left、right或both
str_pad("fang yongchao", 20, "right")
```
base R中可以使用`format()`函数
```{r}
format("fang yongchao", width = 20, justify = "left")
```
性能没差
```{r}
stringr <- 'str_pad("fang", 20, "right")'
base_r <- 'format("fang", width = 20)'
microbenchmark(
  eval(parse(text = stringr)),
  eval(parse(text = base_r))
)
```
## `str_trunc()`
将字符串变短，用...代替删除部分，base R中不确认是否有相同功能函数
```{r}
# 变短方向可为left、right、center 
str_trunc("fang yongchao", 10, "right")
```


## `str_trim()`
删除字符串两侧多余空格，base R中不确认是否有相同功能函数
```{r}
# 删除方向left、right或both
str_trim("fang yongchao    ", "right")
```

# locale sensitive

此类函数都包含一个**locale**参数，对于不同的语言返回结果不同,默认是英语

## `str_to_title()`
转换成标题，即单词首字母大写
```{r}
str_to_title("fang yongchao")
```

## `str_to_upper()`
转换成大写
```{r}
str_to_upper("I like fang yongchao")
```

## `str_to_lower()`
转换成小写
```{r}
str_to_lower("I like horses")
# 换一种语言，小写不一样了
str_to_lower("I like horses", locale = "tr")
```

## `str_order()`和`str_sort()`
排序，逻辑类似于base R中的`order()`和`sort()`
```{r}
str_order(c("y", "i", "k"))
str_sort(c("y", "i", "k"))
# sort排序，换一种语言，排序结果改变了
str_sort(c("y", "i", "k"), locale = "lt")
```

# pattern 匹配

此类函数包含`detect()`、`locate()`、`extract()`、`match()`、`replace()`、`split()`六个函数，这六个函数的前两个参数均为要进行操作的**string**和进行匹配用的**pattern**

```{r}
string <- c(
  "apple",
  "219 733 8965",
  "329-293-8753",
  "Word: 579-499-7527; Home:543.355.3679"
)
phone <- "([2-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})"
strings <- string
```

## `str_detect()`
判断字符串中是否存在**pattern**，返回bool值
```{r}
str_detect(string, phone)
```
base R中可以用`grepl()`函数
```{r}
grepl(phone, string)
```
性能上base R更有优势
```{r}
stringr <- 'str_detect(string, phone)'
base_r <- 'grepl(phone, string)'
microbenchmark(
  eval(parse(text = stringr)),
  eval(parse(text = base_r))
)
```

## `str_subset()`
返回**string**中包含**pattern**的字符串，返回vector
```{r}
str_subset(string, phone)
```
base R中使用`grep()`函数
```{r}
grep(phone, string, value = TRUE)
```
性能上base R更有优势
```{r}
stringr <- 'str_subset(string, phone)'
base_r <- 'grep(phone, string, value = TRUE)'
microbenchmark(
  eval(parse(text = stringr)),
  eval(parse(text = base_r))
)
```

## `str_which()`
返回**string**中存在**pattern**的字符串的下标，返回vector
```{r}
str_which(string, phone)
```
base R中同样使用`grep()`函数
```{r}
grep(phone, string, value = FALSE)
```
性能上base R更有优势
```{r}
stringr <- 'str_which(string, phone)'
base_r <- 'grep(phone, string, value = FALSE)'
microbenchmark(
  eval(parse(text = stringr)),
  eval(parse(text = base_r))
)
```

## `str_count()`
返回字符串中**pattern**的数量
```{r}
str_count(string, phone)
# 特别地，当pattern为空时，就是str_length()
str_count(string, "")
```

## `str_locate()`和`str_locate_all()`：返回**pattern**在字符串中的位置

```{r}
# str_locate()仅返回第一个，返回dataframe
str_locate(strings, phone)
```

```{r}
# str_locate_all()返回所有，返回的是一个list
str_locate_all(strings, phone)
```

## `str_extract()`和`str_extract_all()`：提取字符串中满足**pattern**的部分

```{r}
# str_extract()仅返回第一个，返回vector
str_extract(strings, phone)
```

```{r}
# str_extract_all()返回全部，默认返回一个list
str_extract_all(strings, phone)
```

## `str_match()`和`str_match_all()`：在extract的基础上，提取**pattern**中用小括号选取的部分

```{r}
str_match(strings, phone)
```

```{r}
str_match_all(strings, phone)
```

## `str_replave()`和`str_replace_all()`：将字符串中满足**pattern**的部分替换

```{r}
str_replace(strings, phone, "XXX-XXX-XXXX")
```

```{r}
str_replace(strings, phone, "XXX-XXX-XXXX")
```

## `str_split()`：将一个字符串分成几个子串，分隔符为**pattern**

```{r}
str_split(c("a-b-c", "x-y"), "-")
```

# 一些其它的函数

以下三个函数在[Introduction to stringr](https://mirrors.tuna.tsinghua.edu.cn/CRAN/web/packages/stringr/vignettes/stringr.html)中没有提到，功能类似基础函数包中的`paste()`系列函数。

```{r}
myname <- c("fang", "yongchao")
hername <- c("gong", "yufang")
```

## `str_c()`和`str_flatten()`：连接字符串

- **sep**：决定不同字符向量的对应位置字符串通过什么连接
- **collapse**：决定一个字符向量中各字符串通过什么连接

```{r}
str_c(myname, hername, sep = "*", collapse = " ")
```

```{r}
# 一个只有collapse功能的str_c
str_flatten(myname, collapse = " ")
```

## `str_view()`：能够直观看到**string**中符合**pattern**的部分

```{r, eval=FALSE}
# 结果需要通过html显示
# NOT RUN
str_view(string, pattern)
```

# 正则表达式（待补全）

[Regular Expressions](https://mirrors.tuna.tsinghua.edu.cn/CRAN/web/packages/stringr/vignettes/regular-expressions.html)


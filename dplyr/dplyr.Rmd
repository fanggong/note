---
title: "dplyr包学习笔记"
author: "Fang Yongchao"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
    number_section: true
  runtime: shiny
---
```{r PACKAGES, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(stringr)
```

# 对单个表进行操作

```{r, echo=FALSE, message=FALSE, warning=FALSE}
df <- tibble(month = c(1,2,2,3,3,3,4,4,4,4),
             day = c(2,3,4,3,5,6,4,6,6,4),
             num = c(2,4,2,4,2,2,4,6,4,8))
```

```{r}
df
```

## `filter()`：选择样本

```{r}
# 用逗号分隔多个条件表示且
df %>% filter(month %in% 3:4, day == 4)
```

```{r}
# 用逻辑符分隔多个条件
df %>% filter(month %in% 3:4 | day == 4)
```

```{r}
# 参数.preserve
# 对分组后的tbl进行filter时是否保留原数据分组
df %>% 
  group_by(month) %>% 
  filter(month %in% 1:3, .preserve = TRUE) %>% 
  group_keys()
```

## `filter_all()`、`filter_at()`、`filter_if()`：`filter()`变体

- `filter_all()`：对所有变量进行某条件的filter
- `filter_if()`：对满足条件的某些变量进行某条件的filter
- `filter_at()`：对特定的某些变量进行某条件的filter
- 某条件用`all_var()`和`any_var()`进行表示
- 特定的某些变量用`vars()`表示，参数与`select()`参数一样
- 满足条件的某些变量用`~function(.)`表示，该函数返回逻辑值

```{r}
# 保留所有变量的值都大于3的行
df %>% filter_all(all_vars(. > 3))
```

```{r}
# 保留存在某个变量的值大于3的行
df %>% filter_all(any_vars(. > 3))
```

```{r}
# 对所有值都大于5的变量进行filter
# 被选中的变量的值都大于3
df %>% filter_if(~all(. < 5), all_vars(. < 3) )
```

```{r}
# 对month和num两个变量进行filter
# 所有变量的值都大于3
df %>% filter_at(vars(month, num), all_vars(. < 3) )
```

## `arrange()`：排序

```{r}
# 默认升序，通过desc改成降序
df %>% arrange(month, desc(day))
```

```{r}
# 对group_by对象进行arrange要设置.by_group参数
df %>% 
  group_by(month) %>% 
  arrange(day, .by_group = TRUE)
```

## `arrange_all()`、`arrange_at()`、`arrange_if()`：`arrange()`变体

- 特定的某些变量用`vars()`表示，参数与`select()`参数一样
- 满足条件的某些变量用`~function(.)`表示，该函数返回逻辑值
- 通过`list(~function(.))`来决定排序的方式

```{r}
# 对所有变量进行降序排列
df %>% arrange_all(list(~desc(.)))
```

```{r}
# 对满足所有值都小于5的变量进行降序排列
df %>% arrange_if(~all(. < 5), list(~desc(.)))
```

```{r}
# 对month和day两个变量进行降序排列
df %>% arrange_at(vars(month, day), list(~desc(.)))
```

## `select()`和`rename()`：通过列名选取某些列

```{r}
# select()选取month、day三列
df %>% select(month, day)
```

```{r}
# select()删除month、day三列
df %>% select(-c(month, day))
```

```{r}
# rename()修改列名
df %>% rename(YUE = month, RI = day, NUM = num)
```

```{r}
# 一个奇葩情况：select()的列名参数是一个由列名组成的向量，而该
# 向量的名称恰好又是某列列名。解决方法如下：
vars <- c("month", "day", "num")
df %>% 
  mutate(test = "X") %>% 
  select(!!vars)
```

## `select_all()`、`select_at()`、`select_if()`：`select()`变体

- 特定的某些变量用`vars()`表示，参数与`select()`参数一样
- 满足条件的某些变量用`~function(.)`表示，该函数返回逻辑值
- 通过`list(~function(.))`来对选取的变量的变量名进行操作

```{r}
# 选取所有变量，并将变量名toupper
df %>% select_all(list(~toupper(.)))
```

```{r}
# 选取满足所有值小于5的变量，并将变量名toupper
df %>% select_if(~all(. < 5), list(~toupper(.)))
```

```{r}
# 选取month和day两个变量，并将变量名toupper
df %>% select_at(vars(month, day), list(~toupper(.)))
```

## `rename_all()`、`rename_at()`、`rename_if()`：`rename()`变体

- 使用方法与`select()`变体一致
- `rename_all()`和`select_all()`完全一致
- `rename_at()`、`rename_if()`和`select_at()`、`select_if()`的区别是
`rename_at()`、`rename_if()`会保留未被选取的变量

## `distinct()`：删除tbl中的重复行

- 可以选择以哪些行作为标准进行distinct
- 对于重复的行仅保留第一行

```{r}
# 通过.keep_all参数设定是否保留所有列
df %>% 
  sample_n(100, replace = TRUE) %>% 
  distinct(month, .keep_all = TRUE)
```

## `distinct_all()`、`distinct_at()`、`distinct_if()`：`distinct()`变体

- 特定的某些变量用`vars()`表示，参数与`select()`参数一样
- 满足条件的某些变量用`~function(.)`表示，该函数返回逻辑值
- 通过`list(~function(.))`来对选取的变量进行操作，之后distinct

```{r}
# 将每一列的值改为该列的平均值后distinct
df %>% 
  distinct_all(~mean(.))
```

```{r}
# 不对变量进行操作的话，distinct_at()和distinct()功能一样 
df %>% 
  distinct_at(vars(month, day))
```

```{r}
df %>% 
  distinct_if(~all(. < 5), .keep_all = TRUE)
```

## `mutate()`、`transmutate()`：添加列，值可以基于已有列

```{r}
# mutate会保留所有列
df %>% 
  mutate(double_num = 2 * num,
         exp_double_num = exp(double_num))
```

```{r}
# transmute只保留计算出的结果列
df %>% 
  transmute(double_num = 2 * num,
            exp_double_num = exp(double_num))
```

## `mutate_all()`、`mutate_at()`、`mutate_if()`：`mutate()`变体

- 特定的某些变量用`vars()`表示，参数与`select()`参数一样
- 满足条件的某些变量用`~function(.)`表示，该函数返回逻辑值
- 通过`list(~function(.))`来对选取的变量进行操作，结果直接取代被选取的变量
- 通过`list(var_name = ~function(.))`来对选取的变量进行操作并增加新的变量

```{r}
# 对所有变量进行scale，结果添加在新的变量中
df %>% 
  mutate_all(list(scale = ~scale(.)))
```

```{r}
# 对month和day两个变量进行scale
df %>% 
  mutate_at(vars(month, day), scale)
```

```{r}
# 对满足所有值都小于5的变量进行scale
df %>% 
  mutate_if(~all(. < 5), scale)
```

## `transmute_all()`、`transmute_at()`、`transmute_if()`：`transmute()`变体

- 使用方法与`mutate()`变体一样，但是仅返回结果的变量

```{r}
df %>% 
  transmute_all(list(scale = ~scale(.)))
```

## `summarise()`：求统计值

```{r}
# summarise()求dep_delay的均值
df %>% summarise(num_mean = mean(num))
```

## `summarise_all()`、`summarise_at()`、`summarise_if()`：`summarise()`变体

- 使用方法与`mutate()`变体一样

```{r}
df %>% 
  summarise_at(vars(month, day), list(mean = mean, sd = sd))
```

## `group_by()`：基于列的值将表分组，搭配别的函数使用

```{r}
# group_by() + summarise()
df %>% 
  group_by(month) %>% 
  summarise(
    count = n(),
    distinct_day = n_distinct(day),
    num_mean = mean(num)
  )
```

```{r}
# group_by() + do()
df %>% 
  group_by(month) %>% 
  do(result = scale(.))
```

```{r}
# 参数add设定是新增分组还是重新分组
df %>% 
  group_by(month) %>% 
  group_by(day, add = TRUE) %>% 
  group_keys()
```

## `group_by_all()`、`group_by_at()`、`group_by_if()`：`group_by()`变体

- 特定的某些变量用`vars()`表示，参数与`select()`参数一样
- 满足条件的某些变量用`~function(.)`表 示，该函数返回逻辑值
- 通过`list(~function(.))`来对选取的变量进行操作，之后group_by

```{r}
# 对所有变量的值exp后分组
df %>% 
  group_by_all(~exp(.)) %>% 
  group_keys()
```

```{r}
# 对month变量的值exp后分组
df %>% 
  group_by_at(vars(month), ~exp(.)) %>% 
  group_keys()
```

```{r}
# 对满足存在值大于5的变量的值exp后分组
df %>% 
  group_by_if(~any(. > 5), ~exp(.)) %>% 
  group_keys()
```

## `group_split()`、`group_key()`：`group_by`

```{r}
# group_split()返回一个list而不是group_by对象
df %>% group_split()
```

```{r}
# group_keys()返回分组用的key
df %>% group_keys(month, day)
```

## `group_rows()`、`group_data()`：返回分组后各组的所在行

```{r}
# group_rows()返回group_by对象的各个分组的所在行
df %>%
  group_by(day) %>% 
  group_rows()
```

```{r}
# group_data()返回group_by对象的各个分组的key和所在行
df %>%
  group_by(day) %>% 
  group_data()
```

## `group_map()`、`group_modify()`：`group_by()` + `do()`进阶版

```{r}
# group_map()接收一个group_by对象，返回list
df %>% 
  group_by(month) %>% 
  group_map(~scale(.))
```

```{r}
# group_modify()接收一个group_by对象，返回data.frame
df %>% 
  group_by(month) %>% 
  group_modify(~as.data.frame(scale(.)))
```

## `sample_n()`和`sample_frac()`：随机抽样

```{r}
# sample_n()固定数量抽样
df %>% sample_n(5)
```

```{r}
# sample_frac()固定比例抽样
df %>% sample_frac(0.2)
```

## `top_n()`、`top_frac()`：取值最大的前n行

- 值的大小由`min_rank()`函数判断

```{r}
# top_n()固定数量取前n行
df %>% 
  mutate(rank = row_number()) %>% 
  top_n(-5, wt = rank)
```

```{r}
# top_frac()固定比例取前n行
df %>% 
  mutate(rank = row_number()) %>% 
  top_frac(-0.5, wt = rank)
```

# 对多个表进行操作

```{r}
(df1 <- tibble(x = c(1,1,3,4), y = 1:4))
(df2 <- tibble(x = c(1,1,2), z = c("a","b","a")))
(df3 <- tibble(not_x = c(1,1,4,5), not_y = c(1,1,4,5)))
```

## `left_join()`、`right_join()`、`inner_join()`和`full_join()`：与SQL中的join用法相同

```{r, message=FALSE}
# 用两个表中相同列名的列join
df1 %>% left_join(df2, by = "x")
```

```{r, message=FALSE}
# 用两个表中不同列名的列join
df1 %>% left_join(df3, c("x" = "not_x"))
```

## `semi_join(x, y)`：返回在x中与y可以匹配的行

```{r}
# 函数名中虽然有join，但是并没有join的操作，返回值仅仅是x的子集
# 当用于匹配的列无重复值时，效果和inner_join很像
semi_join(df1, df2, by = "x")
```

## `anti_join(x, y)`：返回在x中无法与y进行匹配的行

```{r}
anti_join(df1, df2, by = "x")
```

## `nest_join(x, y)`：

- `nest_join(x, y)`会在x后新增一列，该列的每一项是y中对应可以被join的子集
- `nest_join(x, y)`可以通过一些操作转换成任意一种join

```{r}
# inner_join()
df1 %>% 
  nest_join(df2, by = "x") %>% 
  tidyr::unnest(cols = c(df2))
```

```{r}
# left_join()
df1 %>% 
  nest_join(df2, by = "x") %>% 
  tidyr::unnest(cols = c(df2), keep_empty = TRUE)
```

## `intersect()`：交集

```{r}
# 会自动删除重复数据
intersect(df1, df3 %>% rename(x = not_x, y = not_y))
```

## `union()`：并集

```{r}
# 依然自动删除重复数据
union(df1, df3 %>% rename(x = not_x, y = not_y))
```

## `setdiff(A, B)`：A - B

```{r}
setdiff(df1, df3 %>% rename(x = not_x, y = not_y))
setdiff(df3 %>% rename(x = not_x, y = not_y), df1)
```

# 窗口函数

R中的窗口函数，可包括以下几类：

- 排序相关的函数：`row_number()`、`min_rank()`、`dense_rank()`、`cume_dist()`、`percent_rank()`、`ntile()`，以一个向量所谓输入参数，返回一个某种类型的排序
- `lead()`和`lag()`，我也不知道叫什么函数，`lead()`向后取向量中元素，`lag()`向前取向量中元素
- Cumulative：`cumsum()`、`cummin()`、`cummax()`、`cumall()`、`cumany()`、`cummean()`
- 一些其它包里的函数，如[RcppRoll](https://cran.r-project.org/web/packages/RcppRoll/index.html)

## `row_number()`、`min_rank()`和`dense_rank()`：排序

```{r}
# 最简单的排序，结果就是12345...
row_number(c(1,1,2,2,1))
```

```{r}
# rank排序，存在并列，并且并列时之后的排名会依次向后跳
min_rank(c(1,1,2,5,1))
```

```{r}
# dense_rank排序，存在并列，但是并列时之后的排名不会
dense_rank(c(1,1,2,2,1))
```

## `cume_dist()`：小于等于该值的值的数量占所有值的百分比

```{r}
cume_dist(c(1,1,1.2,3,1))
```

## `percent_rank()`：返回rank的百分比，最小为0，最大为1

```{r}
spl <- rnorm(100)
s1 <- percent_rank(spl)
s2 <- (min_rank(spl) - min(min_rank(spl))) / 
  (max(min_rank(spl)) - min(min_rank(spl)))
all(s1 == s2)
```

## `ntile()`：按照`row_number()`的顺序分成几组

```{r}
ntile(c(1:5,5:1), 4)
```

## `lead()`和`lag()`：跨位提取元素

```{r}
# lead向后取
lead(c(1:5))
```

```{r}
# lag向前取
lag(c(1:5), 2)
```

## `cumsum()`、`cummin()`、`cummax()`、`cumall()`、`cumany()`和`cummean()`：Cumulative的sum、min、max、all、any和mean，搭配`order_by()`使用有特殊效果

```{r}
# 普通的cumsum，从前往后依次sum
cumsum(c(1:5))
```

```{r}
# 通过order_by，打乱顺序sum
order_by(c(3,2,1,5,4), cumsum(1:5))
```

# 小函数

## `all_equal()`：判断两个dataframe是否一致

```{r}
all_equal(sample(df, 10, replace = TRUE), sample_n(df, 10, replace = TRUE))
```

## `between()`：比写大于小于号更快

```{r}
between(c(1:10), 3, 6)
```

## `bind_rows()`、`bind_cols()`：按行合并和按列合并

- `bind_rows()`取代了dplyr包中的`rbind_list()`和`rbind_all()`，但是速度都不如data.table包中的`rbindlist()`

```{r}
bind_rows(list(df[1:3, ], df[4:6, ], df[7:10, ]))
```

```{r}
bind_cols(list(df[1], df[2], df[3]))
```

## `case_when()`：取代多个`ifelse()`

```{r}
spl <- c(1,2,3,NA)
case_when(
  spl == 1 ~ "壹",
  spl == 2 ~ "贰",
  spl == 3 ~ "叁",
  TRUE ~ "无"
)
```

## `na_if()`：将某些值替换成NA

```{r}
# 将3替换成NA
na_if(c(1,2,3,4), 3)
```

## `near()`：判断两个数字是否足够接近

```{r}
# 两个值的差距必须要小于tol，等于不行
near(c(1, 2, 3), c(1.11, 2.2, 3.29), tol = c(0.1, 0.2, 0.3))
```

## `first()`、`last()`、`nth()`：取向量的第1个、最后1个、第n个数

```{r}
first(c(1,2,3,4), order_by = c(3,2,1,4))
```

```{r}
last(c(1,2,3,4), order_by = c(3,2,1,4))
```

```{r}
nth(c(1,2,3,4), 3, order_by = c(3,2,1,4))
```

## `n_distinct()`：等价于`length(unique())`，速度更快

```{r}
n_distinct(sample(1:10, 100, replace = TRUE))
```

## `recode()`：简化版`case_when()`

```{r}
recode(c(1,2,3,NA), `1` = "壹", `2` = "贰", .missing = "无", .default = "叁")
```

## `rowwise()`：每行作为一组来`group_by()`

```{r}
df %>% rowwise()
```

## `slice()`：对tibble进行切片

```{r}
# 取前三行
df %>% slice(1:3)
```

```{r}
# 分组后对每组取前三行
df %>% group_by(month) %>% slice(1:2)
```

# 编程技巧

                 